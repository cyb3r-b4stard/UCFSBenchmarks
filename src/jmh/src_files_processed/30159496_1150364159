package src.findwords;

import java.util.ArrayList;
import java.io.IOException;
/**
 * #### ############## ## ### ##########.
 * #### ## ### #### ###### #### ### ###### ######, ### ### #### ### ###
 * ###### ######.
 */
public class MySearcher implements Searcher {

    public void testEqual(){
        char[] array2 = new char[6];
        char[] array = new char[6];
        int index = 0;
        for (char c = 'a'; c <= 'f'; c++) {
            array[index] = c;	    
            array2[index] = c;
            index++;
        }

        array[0] ='e';
        array2[0] = 'f';
        if(equal(array,array2,6)){
            System.out.println("works");
        }
        else{
            System.out.println("does not work");
        }
    }

    public void testLessThan(){
        char[] array3 = new char[3];
        char[] array4= new char[4];
        array3[0] = 'a';
        array3[1] = 'b';
        array3[2] = 'c';

        array4[0] = 'a';
        array4[1] = 'b';
        array4[2] = 'c';
        array4[3] = 'e';

        int index2 = 0;

        if(lessThan(array3,array4,5)){
            System.out.println("word a is less than word b");
        }
        else{
            System.out.println(" ");
        }

    }
    
   
    
    
    @Override
    public boolean equal(char[] s, char[] t, int n) {
        if((s[0] == t[0] && s[1] == t[1]) || s.length < n || t.length < n){
            if (s.length == t.length){
                for(int i =0; i<s.length; i++){
                    if(s[i] != t[i]){    
                        System.out.println("the first array is not equal to the same as the second array");
                        return false;
                    }
                }

            }

        }else {
            return false;
        }

        return true;
    }

    @Override
    public boolean lessThan(char[] s, char[] t, int n) {
        System.out.println(s + " < s");
         System.out.println(t + " < t");
        if(s.length<=n){
            n = s.length -1;
        }
        System.out.println("n is "+n);
        for (int i=0; i<=n; i++){
            if (s[i]>t[i] && s[i]!=t[i]){
                System.out.println(s[i] + " > " + t[i] + ", hence returns false");
                return false;
            }
        }
        return true;
    } 
    
    
     public void testFindPreFix() throws IOException{
        char[] array5 = new char[3];

        array5[0] = 'c';
        array5[1] = 'a';
        array5[2] = 't';
                                    
        Dictionary d = new Dictionary() ;
        System.out.println("Size "+d.size());
        int results = findPrefix(d, array5, 3);
            System.out.println(" res " + results);
      

    }
    

    @Override
    public int findPrefix(Dictionary d, char[] w, int n) {
        if(n>w.length){
            System.out.println("Exceeds the charcter w array length");
        }
        int arrayStart;
        int arrayEnd;
        int arrayMidPoint;
        arrayStart = 0;
        arrayEnd = w.length;
        System.out.println("this is my arrayStart " + arrayStart + " this is the arrayEnd " + arrayEnd);
        while(arrayStart<=arrayEnd){
            arrayMidPoint = (arrayStart+arrayEnd) / 2;
        
            System.out.println("this is my arrayMid point " + arrayMid)
            char [] mid = d.getWord(arrayMidPoint);
            
            System.out.println("mid[0] is" + mid[0]);
            
            if(lessThan(mid, w, n)){
                

                arrayStart = arrayMidPoint+1;
                                    System.out.println("lessThan returns true. arrayStart " + arrayStart);
            }
            else {
                arrayEnd = arrayMidPoint-1;
                                System.out.println("lessThan returns false. arrayEnd " + arrayEnd);
            }

        }
        return arrayStart;
    }

    @Override
    public ArrayList<char[]> findMatches(Dictionary d, char[] clue) {
        ArrayList<char[]> matches = new ArrayList<>();

        /*Once you have that working, you'll have half of findMatches() done.  The rest is a nested loop,
         * with the outer loop going through positions in the dictionary, and the inner loop going through 
         * positions in the clue and the current word. 
         
        
        chat [] possitions = new ++;
        int k;
        for(int i= 0; i <possitions; i++);{
            for( int j = 0; j< clue.length-1; j++){
            
            }
            
        
        }
        */
        return matches;
    
    }
    
}

