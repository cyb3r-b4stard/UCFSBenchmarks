
/* #### ### #######, ########## #
 * ####: ####### #########
 * ########: ########## 
 * ##: #########
 */

import ecs100.*;
import java.awt.Color;
import java.util.*;
import java.io.*;

/** 
 *  ####### # ######## ## ### ######## #### #### ######### #########.
 *  
 *  # ######## ######## ## # ########## ## ######## ########, #.#., #####.
 *  #### #### ### # #### (##, ######, ## ########, ## ######, ..),
 *  ### # ##### ########### ######## ## ### ######## (#, #, #).
 *
 *  #### ######## ## ######### ## # #### ## # #### ## ######## ######## (#####) ### ##### #########.
 *  ### ######## ## ######## ## ####### # ####### ###### ### #### ####.
 *  ### #### ### ##### ## #### #### ## ########## ## ### #### ## ### ####.
 * 
 *  ### ########### ## ### #### ### ##### ### ######### ### ######### ##### ##
 *  ##### ## ###### ## ### #### "####-###########.###" ##### ###### ## #### ###
 *  ###### ## # ###.  #### ## #### ## ########, ### #### ###### ## ###### ## ##
 *  ### ### ## #### ### #### ### ##### ## #### ## ### ####'# ######() ######
 * 
 *  # ######## ### ## ######## #### ######### ############, ### ### #######
 *  ######## #### ####### ## ####### ### ########### ## ### #########.
 *  
 *  ### ############ ### ####### ######### ######### #####, ##### ### ######## ## ## ## ###
 *  ###### ## # ######### ### ### ###### ######## ###### ### ######### ## ### #########.
 *   "#####" ####### ### ######## #### ### ##### (####### ######## = # #'##### (# #######))
 *   "####" ####### ### ######## #### ### #### (####### ######## = ## #'##### (### #######))
 *   "####" ####### ### ######## #### ### #### (####### ######## = # #'##### (-## #######))
 *   "#####" ####### ### ######## #### ### ##### (####### ######## = # #'##### (## #######))
 *   "##########" ####### ### ####### ######## ## -## ####### (-# #######),
 *   "###########" ####### ### ####### ######## ## ## ####### (# #######).
 *
 *  ## #### #### #### ### ####### ##### ###### ## ##### ## ### ######## #####,
 *  ### ##### #### ## ######## ## ##### #### ### ######## #### ## ### #######.
 *  #### ####### ######## ####### # ######### ######## ## ### #####.
 */

public class MoleculeRenderer {

    private Map<String, AtomInfo> atoms;  

    private List<MoleculeElement> molecule;

    private double currentAngle = 0.0;    

    private double rotationStep = 5.0;    

    /** 
     * [CORE] / [COMPLETION]
     * Sets up the Graphical User Interface and reads the file of element data of
     * each possible type of atom into a Map: where the type is the key
     * and an AtomInfo object is the value (containing size and color).
     */
    public MoleculeRenderer() {

        atoms = new HashMap<>();
        molecule = new ArrayList<>();  

        UI.addButton("Read", () -> {
                String filename = UIFileChooser.open();
                readMoleculeFile(filename);
                view(0, new BackToFrontComparator());
            });

        UI.addButton("FromFront", () -> view(0, new BackToFrontComparator()));

        readAtomInfos();    
    }

    /** 
     *  [CORE] / [COMPLETION]
     *  Reads the molecule data from a file containing one line for each atom in the molecule.
     *  Each line contains an atom type and the 3D coordinates of the atom.
     *  For each atom, the method constructs a MoleculeElement object,
     *  and adds it to the List of molecule elements in the molecule.
     *  To obtain the color and the size of each atom, it has to look up the type
     *  of the respective atom in the Map of atoms.
     */
    public void readMoleculeFile(String fname) {
        molecule.clear();
        try {
            Scanner scan = new Scanner(new File(fname));
            while(scan.hasNext()){
                String Type = scan.next();
                int x = scan.nextInt();
                int y = scan.nextInt();
                int z = scan.nextInt();
                AtomInfo a =atoms.get(Type);
                molecule.add(new MoleculeElement(x,y,z,a.radius,a.col));
            }
        }
        catch(IOException ex) {
            UI.println("Reading molecule file " + fname + " failed.");
        }
    }

    /** 
     *  [COMPLETION]
     *  Reads a file containing radius and color information about each type of
     *  atom and stores the info in a Map, using the atom type as a key.
     */
    private void readAtomInfos() {
        UI.println("Reading the atom definitions...");

        try {
            Scanner scan = new Scanner(new File("atom-definitions.txt"));
            while(scan.hasNext()){
                String Type = scan.next();
                int Size = scan.nextInt();
                Color Col = new Color(scan.nextInt(),scan.nextInt(),scan.nextInt());
                atoms.put(Type,new AtomInfo(Type,Size,Col));
            }
        }catch (IOException ex) {
            UI.println("Reading atom definitions FAILED.");
        }
    }

    public void view (double viewingAngle, Comparator<MoleculeElement> sortingCriterion) {
        currentAngle = viewingAngle;

        if (molecule == null)
            return;
        Collections.sort(molecule, sortingCriterion);

        render(); 
    }

    /**
     *  Renders the molecule, according the the current ordering of Atoms in the List.
     *  The Atom's render() method needs the current perspective angle.
     */
    public void render() {
        UI.clearGraphics();

        for(MoleculeElement moleculeElement : molecule) {
            moleculeElement.render(currentAngle);
        }

    }

    /**    
     * 
     * Private comparator classes.
     * 
     * You will need a comparator class for each different direction
     *
     * Each comparator class should be a Comparator of MoleculeElement, and will define
     * a compare method that compares two atoms.
     * Each comparator must have a compare method.
     * Most of the comparators do not need an explicit constructor and have no fields.
     * However, the comparator for rotating the viewer by an angle may need a field and a constructor.
     */

    /** 
     * [CORE]
     * Comparator that defines the ordering to be from back to front.
     * 
     * Uses the z coordinates of the two atoms;
     * larger z means towards the back,
     * smaller z means towards the front
     * @return
     *  negative if element1 is more to the back than element2,
     *  0 if they are in the same plane,
     *  positive if element1 is more to the front than element2.
     */
    private class BackToFrontComparator implements Comparator<MoleculeElement> {

        public int compare(MoleculeElement element1, MoleculeElement element2) {
           return (int)(element2.getZ())-(int)(element1.getZ());
       }
    }

    /** 
     * Comparator that defines the ordering to be from front to back.
     * 
     * Uses the z coordinates of the two atoms
     * larger z means towards the back,
     * smaller z means towards the front
     * @return
     *  negative if element1 is more to the front than element2, (
     *  0 if they are in the same plane,
     *  a positive number if element1 is more to the back than element2.
     */
    private class FrontToBackComparator implements Comparator<MoleculeElement> {

        public int compare(MoleculeElement element1, MoleculeElement element2) {
            int ans;
            String txt;
            /*# YOUR CODE HERE */

            return 0; 

        }
    }

    /** 
     * Comparator that defines the ordering to be from left to right 
     * 
     *  uses the x coordinates of the two atom
     *  larger x means more towards the right,
     *  smaller x means more towards the left.
     *  @return
     *   negative if element1 is left of element2, 
     *   positive if atom 1 is right of element2.
     *   0 if they are vertically aligned, 
     */
    private class LeftToRightComparator implements Comparator<MoleculeElement> {

        public int compare(MoleculeElement element1, MoleculeElement element2) {
            /*# YOUR CODE HERE */

            return 0; 
        }
    }

    /** 
     * Comparator that defines the ordering to be from right to left 
     * 
     * Uses the x coordinates of the two atoms
     * larger x means more towards the right,
     * smaller x means more towards the left.
     * @return
     *  negative if element1 is more to the right than element2,
     *  0 if they are aligned,
     *  positive if atom 1 is more to the left than element2.       
     */
    private class RightToLeftComparator implements Comparator<MoleculeElement> {

        public int compare(MoleculeElement element1, MoleculeElement element2) {
            /*# YOUR CODE HERE */

            return 0; 
        }
    }

    /** Comparator that defines the ordering to be from further to nearer when viewed from
     *  a given perspective.
     *  Needs:
     *  - a constructor that stores the perspective angle,
     *  - a compare method.
     *  
     *  @return
     *  a negative number if element1 is further than element2 from this angle
     *  0 if they are at the same distance,
     *  a positive number if element1 is nearer than element2 from this angle
     */
    private class PerspectiveComparator implements Comparator<MoleculeElement> {
        /** 
         * You can give this constructor a field to hold the currentAngle,
         * but it can also access the field of the enclosing class directly.
         */

        public int compare(MoleculeElement element1, MoleculeElement element2) {
            /*# YOUR CODE HERE */

            return 0; 
        }
    }

    public static void main(String args[]) {
        new MoleculeRenderer();
    }
}