/**
 * #### ##### #### ########## # ####-#### #### ####
 * 
 * @######  ###### #. ##### ##.
 * @####### ## ### ##; ## ### ##; ## ### ##; ## ### ##; ## ### ##; ## ### ##
 *          ## ### ##; ## ### ##; ## ### ##; ## ### ##; ## ### ##; ## ### ##
 *          ## ### ##; ## ### ##; ## ### ##; ## ### ##; ## ### ##; ## ### ##
 *          ## ### ##
 */

import java.util.StringTokenizer;
import java.util.PriorityQueue;
import java.util.Random;

import org.jfugue.*;  

interface Functor { Object fn(Object x); }

interface Predicate { boolean pred(Object x); }

public class Cons
{
    private Object car;
    private Cons cdr;
    private Cons(Object first, Cons rest)
       { car = first;
         cdr = rest; }
    public static Cons cons(Object first, Cons rest)
      { return new Cons(first, rest); }
    public static boolean consp (Object x)
       { return ( (x != null) && (x instanceof Cons) ); }
    public static Object first(Cons lst) {
        return ( (lst == null) ? null : lst.car  ); }
    public static Cons rest(Cons lst) {
      return ( (lst == null) ? null : lst.cdr  ); }
    public static Object second (Cons x) { return first(rest(x)); }
    public static Object third (Cons x) { return first(rest(rest(x))); }
    public static Object fourth (Cons x) { return first(rest(rest(rest(x)))); }
    public static void setfirst (Cons x, Object i) { x.car = i; }
    public static void setrest  (Cons x, Cons y) { x.cdr = y; }
   public static Cons list(Object ... elements) {
       Cons list = null;
       for (int i = elements.length-1; i >= 0; i--) {
           list = cons(elements[i], list);
       }
       return list;
   }
    public static Object op  (Cons x) { return first(x); }
    public static Object lhs (Cons x) { return first(rest(x)); }
    public static Object rhs (Cons x) { return first(rest(rest(x))); }
    public static boolean numberp (Object x)
       { return ( (x != null) &&
                  (x instanceof Integer || x instanceof Double) ); }
    public static boolean integerp (Object x)
       { return ( (x != null) && (x instanceof Integer ) ); }
    public static boolean floatp (Object x)
       { return ( (x != null) && (x instanceof Double ) ); }
    public static boolean stringp (Object x)
       { return ( (x != null) && (x instanceof String ) ); }

    public boolean equals(Object other) { return equal(this,other); }

public static boolean equal(Object tree, Object other) {
    if ( tree == other ) return true;
    if ( consp(tree) )
        return ( consp(other) &&
                 equal(first((Cons) tree), first((Cons) other)) &&
                 equal(rest((Cons) tree), rest((Cons) other)) );
    return eql(tree, other); }

public static boolean eql(Object tree, Object other) {
    return ( (tree == other) ||
             ( (tree != null) && (other != null) &&
               tree.equals(other) ) ); }

    public String toString() {
       return ( "(" + toStringb(this) ); }
    public static String toString(Cons lst) {
       return ( "(" + toStringb(lst) ); }
    private static String toStringb(Cons lst) {
       return ( (lst == null) ?  ")"
                : ( first(lst) == null ? "()" : first(lst).toString() )
                  + ((rest(lst) == null) ? ")" 
                     : " " + toStringb(rest(lst)) ) ); }

public static int length (Cons lst) {
  int n = 0;
  while ( lst != null ) {
    n++;
    lst = rest(lst); }
  return n; }

public static Cons member (Object item, Cons lst) {
  if ( lst == null )
     return null;
   else if ( item.equals(first(lst)) )
           return lst;
         else return member(item, rest(lst)); }

public static Cons union (Cons x, Cons y) {
  if ( x == null ) return y;
  if ( member(first(x), y) != null )
       return union(rest(x), y);
  else return cons(first(x), union(rest(x), y)); }

public static boolean subsetp (Cons x, Cons y) {
    return ( (x == null) ? true
             : ( ( member(first(x), y) != null ) &&
                 subsetp(rest(x), y) ) ); }

public static boolean setEqual (Cons x, Cons y) {
    return ( subsetp(x, y) && subsetp(y, x) ); }

public static Cons append (Cons x, Cons y) {
  if (x == null)
     return y;
   else return cons(first(x),
                    append(rest(x), y)); }

public static Cons assoc(Object key, Cons lst) {
  if ( lst == null )
     return null;
  else if ( key.equals(first((Cons) first(lst))) )
      return ((Cons) first(lst));
          else return assoc(key, rest(lst)); }

    public static int square(int x) { return x*x; }
    public static int pow (int x, int n) {
        if ( n <= 0 ) return 1;
        if ( (n & 1) == 0 )
            return square( pow(x, n / 2) );
        else return x * pow(x, n - 1); }

public static Object copy_tree(Object tree) {
    if ( consp(tree) )
        return cons(copy_tree(first((Cons) tree)),
                    (Cons) copy_tree(rest((Cons) tree)));
    return tree; }

public static Object subst(Object gnew, String old, Object tree) {
    if ( consp(tree) )
        return cons(subst(gnew, old, first((Cons) tree)),
                    (Cons) subst(gnew, old, rest((Cons) tree)));
    return (old.equals(tree)) ? gnew : tree; }

public static Object sublis(Cons alist, Object tree) {
    if ( consp(tree) )
        return cons(sublis(alist, first((Cons) tree)),
                    (Cons) sublis(alist, rest((Cons) tree)));
    if ( tree == null ) return null;
    Cons pair = assoc(tree, alist);
    return ( pair == null ) ? tree : second(pair); }

public static Cons dummysub = list(list("t", "t"));

public static Cons match(Object pattern, Object input) {
    return matchb(pattern, input, dummysub); }

public static Cons matchb(Object pattern, Object input, Cons bindings) {
    if ( bindings == null ) return null;
    if ( consp(pattern) )
        if ( consp(input) )
            return matchb( rest( (Cons) pattern),
                           rest( (Cons) input),
                           matchb( first( (Cons) pattern),
                                   first( (Cons) input),
                                   bindings) );
        else return null;
    if ( varp(pattern) ) {
        Cons binding = assoc(pattern, bindings);
        if ( binding != null )
            if ( equal(input, second(binding)) )
                return bindings;
            else return null;
        else return cons(list(pattern, input), bindings); }
    if ( eql(pattern, input) )
        return bindings;
    return null; }

public static Object reader(String str) {
    return readerb(new StringTokenizer(str, " \t\n\r\f()'", true)); }

public static Object readerb( StringTokenizer st ) {
    if ( st.hasMoreTokens() ) {
        String nexttok = st.nextToken();
        if ( nexttok.charAt(0) == ' ' ||
             nexttok.charAt(0) == '\t' ||
             nexttok.charAt(0) == '\n' ||
             nexttok.charAt(0) == '\r' ||
             nexttok.charAt(0) == '\f' )
            return readerb(st);
        if ( nexttok.charAt(0) == '(' )
            return readerlist(st);
        if ( nexttok.charAt(0) == '\'' )
            return list("QUOTE", readerb(st));
        return readtoken(nexttok); }
    return null; }

    public static Object readtoken( String tok ) {
        if ( (tok.charAt(0) >= '0' && tok.charAt(0) <= '9') ||
             ((tok.length() > 1) &&
              (tok.charAt(0) == '+' || tok.charAt(0) == '-' ||
               tok.charAt(0) == '.') &&
              (tok.charAt(1) >= '0' && tok.charAt(1) <= '9') ) ||
             ((tok.length() > 2) &&
              (tok.charAt(0) == '+' || tok.charAt(0) == '-') &&
              (tok.charAt(1) == '.') &&
              (tok.charAt(2) >= '0' && tok.charAt(2) <= '9') )  ) {
            boolean dot = false;
            for ( int i = 0; i < tok.length(); i++ )
                if ( tok.charAt(i) == '.' ) dot = true;
            if ( dot )
                return Double.parseDouble(tok);
            else return Integer.parseInt(tok); }
        return tok; }

public static Cons readerlist( StringTokenizer st ) {
    if ( st.hasMoreTokens() ) {
        String nexttok = st.nextToken();
        if ( nexttok.charAt(0) == ' ' ||
             nexttok.charAt(0) == '\t' ||
             nexttok.charAt(0) == '\n' ||
             nexttok.charAt(0) == '\r' ||
             nexttok.charAt(0) == '\f' )
            return readerlist(st);
        if ( nexttok.charAt(0) == ')' )
            return null;
        if ( nexttok.charAt(0) == '(' ) {
            Cons temp = readerlist(st);
            return cons(temp, readerlist(st)); }
        if ( nexttok.charAt(0) == '\'' ) {
            Cons temp = list("QUOTE", readerb(st));
            return cons(temp, readerlist(st)); }
        return cons( readtoken(nexttok),
                     readerlist(st) ); }
    return null; }

public static Cons readlist( Cons lst ) {
    if ( lst == null )
        return null;
    return cons( reader( (String) first(lst) ),
                 readlist( rest(lst) ) ); }

public static Object transform(Cons patpair, Cons input) {
    Cons bindings = match(first(patpair), input);
    if ( bindings == null ) return null;
    return sublis(bindings, second(patpair)); }

public static Cons transformlst(Cons allpats, Cons input) {
    if ( input == null ) return null;
    Cons restt = transformlst(allpats, rest(input));
    Object thist = transformr(allpats, first(input));
    if ( thist == first(input) && restt == rest(input) )
        return input;
    return cons(thist, restt); }

public static Object transformr(Cons allpats, Object input) {
    if ( consp(input) ) {
        Cons listt = transformlst(allpats, (Cons) input);
        return transformrb(allpats, transformlst(allpats, listt)); }
    Object res = transformrb(allpats, input);
    return res; }

public static Object transformrb(Cons pats, Object input) {
    if ( pats == null ) return input;
    if ( input == null ) return null;
    Cons bindings = match(first((Cons)first(pats)), input);
    if ( bindings == null ) return transformrb(rest(pats), input);
    return sublis(bindings, second((Cons)first(pats))); }

public static Object transformfp(Cons allpats, Object input) {
    Object trans = transformr(allpats, input);
    if ( trans == input ) return input;
    return transformfp(allpats, trans); }          

public static boolean varp(Object x) {
    return ( stringp(x) &&
             ( ((String) x).charAt(0) == '?' ) ); }

public static Cons opposites = 
    list( list( "+", "-"), list( "-", "+"), list( "*", "/"),
          list( "/", "*"), list( "sqrt", "expt"), list( "expt", "sqrt"),
          list( "log", "exp"), list( "exp", "log") );

public static String opposite(String op) {
    Cons pair = assoc(op, opposites);
    if ( pair != null ) return (String) second(pair);
    return "error"; }

public static void javaprint(Object item, int tabs) {
    if ( item == null ) System.out.print("null");
    else if ( consp(item) ) javaprintlist((Cons) item, tabs);
    else if ( stringp(item) )
        if ( item.equals("zlparen") ) System.out.print("(");
        else if ( item.equals("zrparen") ) System.out.print(")");
        else if ( item.equals("zspace") ) System.out.print(" ");
        else if ( item.equals("znothing") ) ;
        else if ( item.equals("ztab") ) System.out.print("\t");
        else if ( item.equals("zreturn") ) System.out.println();
        else System.out.print((String)item);
    else System.out.print(item.toString()); }

public static void javaprintlist(Cons lst, int tabs) {
    if ( lst != null ) {
        if ( stringp(first(lst)) )
            if ( ((String)first(lst)).equals("ztab" ) ) tabs++;
            else if ( ((String)first(lst)).equals("zreturn" ) ) {
                System.out.println();
                for (int i = 0; i < tabs; i++) System.out.print("\t"); }
            else javaprint(first(lst), tabs);
        else javaprint(first(lst), tabs);
        javaprintlist(rest(lst), tabs); } }
          
public static Cons formulas = readlist( list( 
   "(= s (* 0.5 (* a (expt t 2))))",
   "(= s (+ s0 (* v t)))",
   "(= a (/ f m))",
   "(= v (* a t))",
   "(= f (/ (* m v) t))",
   "(= f (/ (* m (expt v 2)) r))",
   "(= h (- h0 (* 4.94 (expt t 2))))",
   "(= c (sqrt (+ (expt a 2) (expt b 2))))",
   "(= v (* v0 (- 1 (exp (/ (- t) (* r c))))))" ));

public static int fcount = 0;
public static Random random = new Random(7);

public static String[] instruments = {"[Piano]",
                                      "[Piano]",
                                      "[Piano]",
                                      "[Piano]",
                                      "[bass_drum]",
                                      "[acoustic_snare]",
                                      "[pedal_hi_hat]",
                                      "[crash_cymbal_1]",
                                      "[cowbell]",
                                      "[ride_bell]",
                                      "[hand_clap]",
                                      "[tambourine]" };
public static int[] insttime = new int[12];
public static String[] inststring = new String[12];
    public static String[] durations = {"", "s", "i", "i.", "q",
                                        "q", "q.", "q.", "h",
                                        "h", "h", "h", "h.",
                                        "h.", "h.", "h.", "w",
                                        "w.", "w.", "w.", "w."};
    public static int[] wholedur = {0, 1, 2, 2,
                                    4, 4, 4, 4,
                                    8, 8, 8, 8,
                                    8, 8, 8, 8,
                                    16, 16, 16, 16,
                                    16, 16, 16, 16,
                                    16, 16, 16, 16,
                                    16, 16, 16, 16};

public static void restto(int inst, int time) {
    int diff = time - insttime[inst];
    if ( diff > 0 ) {
        if ( (diff % 2) != 0 ) {
            inststring[inst] += " Rs";
            diff--; }
        if ( (diff % 4) != 0 ) {
            inststring[inst] += " Ri";
            diff -= 2; }
        if ( (diff % 8) != 0 ) {
            inststring[inst] += " Rq";
            diff -= 4; }
        if ( (diff % 16) != 0 ) {
            inststring[inst] += " Rh";
            diff -= 8; }
        while ( diff > 0 ) {
            inststring[inst] += " Rw";
            diff -= 16; }
    }
}

public static void emit(int inst, int time, int d) {
    System.out.println("emit: " + time + " " + instruments[inst] + " " + d);
    restto(inst, time);
    inststring[inst] += (" " + instruments[inst] + durations[d]);
    insttime[inst] = time + d;
}
  
public static void emitp(int voice, String note, int time, int d) {
    System.out.println("emitp: " + time + " " + instruments[voice] + " "
                       + voice + " " + note + " " + d);
    restto(voice, time);
    if ( d == wholedur[d] )
       inststring[voice] += ( ((time < insttime[voice]) ? "+" : " ")
                            + note + durations[d]);
       else inststring[voice] += (" " + note + durations[d - wholedur[d]]
                                  + "- " + note + "-" + durations[wholedur[d]]);
    insttime[voice] = time + d;
}

    public static String mstring(int tempo) {
        String all = "";
        for ( int i = 0; i < 4; i++ )
            if ( insttime[i] > 0 ) {
                all += (" V" + i);
                if (tempo > 0)
                    all += (" T" + tempo);
                all += inststring[i]; };
        boolean other = false;
        for ( int i = 4; i < 12; i++ )
            if ( insttime[i] > 0 ) other = true;
        if (other)
           { all += " V9 ";
             for ( int i = 4; i < 12; i++ )
                 if ( insttime[i] > 0 ) {
                    all += (" L" + (i - 3) + " ");
                    all += inststring[i]; }; };
        return all;
    }



    public int hashCode() { return conshash(this); }

    public static int conshash(Object e) {
        Cons object = (Cons) e;   
        return (jenkinshash ((String) first(object)) * 17) ^ ((reshash (rest(object))) * 127);
    }

    public static int reshash(Object e) {
        Cons object = (Cons) e;   int hash = 0;
        for (Cons res = object;  res != null;  res = rest(res)) {
            hash += jenkinshash((String) first(res));
        }
        return hash;
    }

    public static int jenkinshash(String key) {
        int hash = 0;
        for (int i = 0;  i < key.length();  i++) {
            hash += key.charAt(i);
        }
        return hash;
    }
    
    public static int totaltime(Cons action) {
        if (first(action) == null)
            return 0;
        else if (first(action).equals("seq"))
            return totaltime(rest(action));
        else if (first(action).equals("sync")) {
            action = rest(action);
            if (consp(action) == true)
                return Math.max(totaltime((Cons) first(action)), totaltime(rest(action)));
            else if (third(action) == null)
                return Math.max(totaltime((Cons) first(action)), totaltime((Cons) second(action)));
            else if (fourth(action) == null)
                return Math.max(Math.max(totaltime((Cons) first(action)), totaltime((Cons) second(action))), Math.max(totaltime((Cons) third(action)), 0));
            else
                return totaltime((Cons) first(action));
        }   
        else if (first(action).equals("repeat"))
            return (int) second(action) * totaltime((Cons) third(action));
        else if (first(action).equals("boom") || (first(action).equals("bell") || (first(action).equals("kaboom") || (first(action).equals("cymbal")))))
            return (int) second(action);
        else if (first(action).equals("piano"))
            return (int) fourth(action);
        else
            return totaltime((Cons) first(action)) + totaltime(rest(action));
    }

    public static PriorityQueue initpq(Cons action) {
        PriorityQueue pq = new PriorityQueue();
        pq.add(new Event(action, 0));
        System.out.println("new program: " + action.toString());
        for ( int i = 0; i < 12; i++ ) {
            inststring[i] = "";
            insttime[i] = 0; };
        return pq; }

    public static PriorityQueue
           addevent(PriorityQueue pq, Cons action, int time) {
        if ( action != null ) pq.add(new Event(action, time));
        return pq; }

        public static void simulator(PriorityQueue pq) {
        while ( pq.size() > 0 ) {
            Event e = (Event) pq.poll();
            int tm = e.time();
            Cons act = e.action();
            execute(pq, act, tm);
        }
        return;
     }

    public static void execute(PriorityQueue pq, Cons act, int time) {
        String command = (String) first(act);
        
        if ( command.equals("seq") ) {
            addevent(pq, rest(action), 0));
        }

        if ( command.equals("boom") ) {
            emit(4, time, (int)(Integer)second(act));
            return; }
        

    }



    public static void main( String[] args ) {

        Cons hashtest =  (Cons) readlist(list("(a)", "(a b)", "(a b c ab +)"));
        for (Cons hptr = hashtest; hptr != null; hptr = rest(hptr) ) {
            Cons ls = (Cons) first(hptr);
            for (Cons ptr = ls; ptr != null; ptr = rest(ptr) ) {
                String s = (String) first(ptr);
                int shash = s.hashCode();
                System.out.println("Hash of " + s + " = " + shash); }
            System.out.println("Hash of " + ls.toString() + " = "
                               + ls.hashCode());  }
        fcount = 0;

        final Functor myf = new Functor()
            { public Object fn (Object x)
                { fcount++;
                  return Math.sqrt((Double) x); }};

        Memoizer mymem = new Memoizer(myf);
        Double[] vals = { 2.0, 3.0, 4.0, 2.0, 2.5, 3.0, 3.5};
        for (int i=0; i < vals.length; i++ )
            System.out.println("Fn of " + vals[i] + " = " +
                               mymem.call(vals[i]));
        System.out.println("Number of function calls = " + fcount);
        

 Player player = new Player();

        PriorityQueue pqa = initpq((Cons) reader("(seq (boom 4) (bell 4))"));
        simulator(pqa);
        String stra = mstring(0);
        System.out.println(stra);
  player.play(new Pattern(stra));




      }

}