/**
 * #### ##### ######### ## ######### ###### #### ## ########.
 * 
 * ## #### ####### #:
 * #. ### #### ## ### #### ## ##### ##### ### ###### ## #######.
 * #. ### #### ####### ##### ## ## ##### ### ####### ## ### ####.
 * 
 * #### ##### ########## ### ### ## #####.
 * 
 * @###### ####### ###### 
 * @####### ######### ####
 * 
 */
public class ListOfNVersion01PartA
{   
    private int[] list;  

    /**
     * This constructor initializes the list to the same values
     * as in the parameter.
     *
     * @param  element   the initial elements for the list
     */
    public ListOfNVersion01PartA(int [] element)
    {




        list = new int[element.length];

        for ( int i=0 ; i<element.length ; ++i ) 
        {
           list[i] = element[i];
        }
    } 

    /**
     * @return     the number of elements stored in this list 
     */
    public int getListSize()
    {
        return list.length; 

        /* See Nielsen page 85-86,
         * section 4.2.3 Retrieving the size of arrays: length
         * 
         * See Parsons page 45,
         * section 3.3.4 The Array ?length? Field and also page 47
         */ 
    } 

    /**
     * @return     the last element in the list
     */
    public int getLast()
    {
        return list[list.length-1]; 

        /* See Nielsen page 85-86,
         * section 4.2.3 Retrieving the size of arrays: length
         * 
         * See Parsons page 45,
         * section 3.3.4 The Array ?length? Field and also page 47
         */
    } 

    /**
     * prints the contents of the list, in order from first to last
     */
    public void printList()
    {

        System.out.print("{" + list[0]);

        for ( int i=0 ; i<list.length ; ++i ) 
        {
           System.out.print(", " + list[0]);
        }

        System.out.print("}");
    } 

    /**
     * This method is NOT examinable in this test.
     * 
     * prints the contents of the list, in order from first to last, and
     * then moves the cursor to the next line
     */
    public void printlnList()
    {
        printList();
        System.out.println();

    } 

    /**
     * @return     the number of times the element occurs in the list
     * 
     * @param  element   the element to be counted
     */
    public int countElement(int element)
    {
        int count = 0; 



        for ( int i=0 ; i<list.length ; ++i ) 
        {
           if ( list[i] == element ) ++count;
        }
        return count;
    } 

    /**
     * @return     the number of times the replacement was made
     * 
     * @param  replaceThis   the element to be replaced
     * @param  withThis      the replacement
     */
    public int replaceAll(int replaceThis, int withThis)
    {
        int count = 0; 


        for ( int i=1 ; i<list.length ; ++i ) 
        {
         if ( list[i] == replaceThis ) 
         { 
             list[i] = withThis;
             ++count;
        }
        return count;
      } 
    }
    /**
     * @return     the first position in list occupied by the parameter value, or -1 if it is not found
     * 
     * @param  findThis   the value to be found
     */
    public int findUnSorted(int findThis)
    {  




        int i=0;

        while ( i<list.length && list[i] != findThis ) 
        
          ++i;

        if ( i<list.length )
           return i;
        else
           return -1;
        }

    /**
     * @return     the position of the smallest element in the array, between positions "first" and "last"
     */
    public int minPos()
    {
        int mostWantedHolder = 0;  
    

        
        for ( int i=0 ; i<list.length ; ++i ) 
        {
         if ( list[i] < list[mostWantedHolder] ) 
             { 
                 mostWantedHolder = i;
                
        }
       }
        return mostWantedHolder;
    
        /* Exercise for students: implement the analogous method "maxPos", both
         * with constant subscripts for ListOf4, as shown above, and with a variable
         * subscript, as required in the previous exercise above.  The method
         * "maxPos" is examinable in future tests.
         */
      } 
    
    
    /**
     * Inserts an element in the last position. The elements already in the
     * list are pushed down one place, and the element that was previously
     * first is lost from the list.
     * 
     * @param  newElement   the element to be inserted
     */
    public void insertLast(int newElement)
    {   

      
        for ( int i=list.length-1 ; i>0 ; ++1 ) 
        {
           list[i] = list[i+1]
        }
        list[list.length-1] = newElement;
       
       
    } 

    

} 
