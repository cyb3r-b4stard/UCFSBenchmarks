/*
 *  ######.#### -- #### #/# ######### ####.
 *  ###### ####### #####
 */

/*
 *  #####: #### ########## # #### (##### ##, ##### ###) ####### #####.
 *  ######## ### ######### ## ### "#########" #####, ##### #### ## # ########
 *  ######, #### "#########_####" ######## ## ### #### ##### ####, "#########_####"
 *  ######## ## ### ###### ####### ####, ### "#########_####" ########## ### ####
 *  ####### ### ## ### ######.
 *
 *  #### ## *###* ## ######### ### ## ##### #### ########## ####### ### #### #####
 *  ## #### ### #### ##### ####### ###### ## ###########.
 *
 *  ##### ####### ### ####### ## ### #### ######### #### ##### ### ### #### ## ########
 *  ## ### #### ####### ####:
 *
 *      ### #######.#####_##_#### (### ###)
 *      ### #######.#####_##_##### (### ###)
 *      ### #######.#####_##_###### (### ###)
 *
 *  ##### ###### ############ ### ####, ##### ### ###### ### # ########## #####.
 */

/*
 *  ####: ### ### #### #######, ### ### *###* ### ########## ####### #### ## ######### ####.
 *  #### ######### ###### ### #######.  ## ### #### #### #######, ###'## #### ## ## ####
 *  ########.  ### ######### ## #### #### ###### ## ## #### ### ######## #### ###### ## #
 *  #### ### ## ###### #### #### ##### ######## #####.
 *
 *  ## ### #### ####### ##### #### ### ###/###### ###, ###### ### ## ### ######### #+# #####,
 *  ###### #### ### ######'# ###### ####.
 */

public class DSched
{
    /*{{{  private class ReadReq*/
    /*
     *  local class/structure to hold read requests
     */
    private class ReadReq
    {
        int blk;        /* block number */
        BRequest req;       /* request info */

        /* constructor: just clear fields */
        public ReadReq ()
        {
            blk = -1;
            req = null;
        }
    }
    /*}}}*/

    /* Private state */
    private ReadReq readqueue[];
    private int readqueue_head;
    private int readqueue_tail;
    private int readqueue_size;
    
    private int readqueue_lasttrack;
    int blockCount;


    /*{{{  public DSched ()*/
    /*
     *  Constructor, initialises various local state.
     */
    public DSched ()
    {
        readqueue = new ReadReq[DiskSim.MAXREQUESTS];
        readqueue_head = 0;
        readqueue_tail = 0;
        readqueue_size = 0;
        readqueue_lasttrack  = 0;
        blockCount = 0;

        /* allocate individual ReadReq entries */
        for (int i=0; i<readqueue.length; i++) {
            readqueue[i] = new ReadReq ();
        }
    }
    /*}}}*/

    /*{{{  public void blockread (int blk, BRequest req)*/
    /*
     *  Called by higher-level code to request that a block is read.
     */
    public void blockread (int blk, BRequest req)
    {
        /* add the request to the head of the queue */
        readqueue[readqueue_head].blk = blk;
        readqueue[readqueue_head].req = req;

        /* increment head pointer (modulo buffer size) */
        readqueue_head = (readqueue_head + 1) % DiskSim.MAXREQUESTS;
        readqueue_size++;
    }
    /*}}}*/
    /*{{{  public void readcomplete (int blk, BRequest req)*/
    /*
     *  Called by lower-level (disk) code when a read has completed and the next
     *  read can be dispatched.  If "blk" < 0 or "req" == null, then this is telling
     *  us that the disk is idle and ready to accept a new read request.
     */
     
     
    public void readcomplete (int blk, BRequest req)
    {
        if (blk >= 0) {
            /* give the block read back to the high-level system */
            DiskSim.highlevel_didread (blk, req);
        }
        
        
        
        
        int whichBlock = -1;
        int distanceFromLast = 99999;
        int trackPosition;
        
        for(int i = 0; i < readqueue_size; i++){
            int position = readqueue_tail + i;
            position  %= DiskSim.MAXREQUESTS
            
            trackPosition = readqueue_lasttrack - DiskSim.block_to_track(readqueue[position].blk);
            if(trackPosition<0) trackPosition *= -1;
            
            
            if(trackPosition < distanceFromLast){
                whichBlock = position;
                distanceFromLast = trackPosition;
            }
        }
        
        if(whichBlock != -1){
            System.out.println("Block count "+ blockCount);
            blockCount++;
            
            DiskSim.disk_readblock(readqueue[whichBlock].blk, readqueue[whichBlock].req);
            readqueue[whichBlock] = readqueue[readqueue_tail];
            readqueue_tail = (readqueue_tail + 1) % DiskSim.MAXREQUESTS;
            readqueue_size--;
            
            readqueue_lasttrack = whichBlock;
        }
        
    }
    /*}}}*/
}
