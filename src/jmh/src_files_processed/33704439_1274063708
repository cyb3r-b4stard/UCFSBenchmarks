package uebung04;
import java.util.LinkedList;
import java.util.*;
import java.lang.reflect.Array;

/**
 * #### ######## ## ######## ### ########## ############## ########
 * 
 * @###### ##### #####
 * @####### #.#
 */
public class Formelsammlung {
  
    /**
     * Diese Methode loest eine quadratische Gleichung mit Hilfe von pq-Formel
     * 
     * @param p
     *            : p-Werte der Gleichung
     * @param q
     *            : q-Werte der Gleichung
     * @param x1
     *            bestimmt die Ausgabe der Methode. Wenn x1 true ist, wird das
     *            Ergebnis fuer x1 zurueckgegeben, sonst wird das Ergebnis fuer
     *            x2 zurueckgegeben
     * @return Ergebnis der quadratischen Gleichung
     */
    public double pqFormel(double p, double q, boolean x1) {
        if (x1 == true) {
            return (p / 2 * -1) + Math.sqrt((p * p) / 4 - q);
        } else {
            return (p / 2 * -1) - Math.sqrt((p * p) / 4 - q);
        }
    }

    /**
     * Diese Methode loest eine quadratische Gleichung mit Hilfe von abc-Formel
     * 
     * @param a
     *            : a-Werte der Gleichung
     * @param b
     *            : b-Werte der Gleichung
     * @param c
     *            : c-Werte der Gleichung
     * @param x1
     *            bestimmt die Ausgabe der Methode. Wenn x1 true ist, wird das
     *            Ergebnis fuer x1 zurueckgegeben, sonst wird das Ergebnis fuer
     *            x2 zurueckgegeben
     * @return Ergebnis der quadratischen Gleichung
     */
    public double abcFormel(double a, double b, double c, boolean x1) {
        if (x1 == true) {
            return ((b * -1) + Math.sqrt((b * b) - 4 * a * c)) / (2 * a);
        } else {
            return ((b * -1) - Math.sqrt((b * b) - 4 * a * c)) / (2 * a);
        }
    }

    /**
     * Diese Methode berechnet einen Flaecheninhalt eines Dreiecks
     * 
     * @param g
     *            : Grundseite eines Dreieckes
     * @param h
     *            : Hoehe eines Dreieckes
     * @return Flaecheninhalt eines Dreiecks
     */
    public double flaecheninhaltDreieck(double g, double h) {
        return (g * h) / 2;
    }

    /**
     * Diese Methode berechnet einen Umfang eines Dreiecks
     * 
     * @param a
     *            : a-Seite
     * @param b
     *            : b-Seite
     * @param c
     *            : c-Seite
     * @return Umfang eines Dreiecks
     */
    public double umfangDreieck(double a, double b, double c) {
        return a + b + c;
    }

    /**
     * Diese Methode berechnet einen Flaecheninhalt eines Rechtecks
     * 
     * @param a
     *            : a-Seite
     * @param b
     *            : b-Seite
     * @return Flaecheninhalt eines Rechtecks
     */
    public double flaecheninhaltRechteck(double a, double b) {
        return a * b;
    }

    /**
     * Diese Methode berechnet einen Umfang eines Rechtecks
     * 
     * @param a
     *            : a-Seite
     * @param b
     *            : b-Seite
     * @return Umfang eines Rechtecks
     */
    public double umfangRechteck(double a, double b) {
        return 2 * (a + b);
    }

    /**
     * Diese Methode berechnet einen Flaecheninhalt eines Parallelogramms
     * 
     * @param a
     *            : a-Seite
     * @param h
     *            : Hoehe
     * @return Flaecheninhalt eines Parallelogramms
     */
    public double flaecheninhaltParallelogramm(double a, double h) {
        return a * h;
    }

    /**
     * Diese Methode berechnet einen Umfang eines Parallelogramms
     * 
     * @param a
     *            : a-Seite
     * @param b
     *            : b-Seite
     * @return Umfang eines Parallelogramms
     */
    public double umfangParallelogramm(double a, double b) {
        return 2 * (a + b);
    }

    /**
     * Diese Methode berechnet einen Flaecheninhalt eines Trapezes
     * 
     * @param a
     *            : a-Seite
     * @param c
     *            : c-Seite
     * @param h
     *            : Hoehe
     * @return Flaecheninhalt eines Trapezes
     */
    public double flaecheninhaltTrapez(double a, double c, double h) {
        return ((a + c) / 2) * h;
    }

    /**
     * Diese Methode berechnet einen Umfang eines Trapezes
     * 
     * @param a
     *            : a-Seite
     * @param b
     *            : b-Seite
     * @param c
     *            : c-Seite
     * @param d
     *            : d-Seite
     * @return Umfang eines Trapezes
     */
    public double umfangTrapez(double a, double b, double c, double d) {
        return a + b + c + d;
    }

    /**
     * Diese Methode berechnet einen Flaecheninhalt eines Kreises
     * 
     * @param r
     *            : Radius
     * @return Flaecheninhalt eines Kreises
     */
    public double flaecheninhaltKreis(double r) {
        return Math.PI * (r * r);
    }

    /**
     * Diese Methode berechnet einen Umfang eines Kreises
     * 
     * @param r
     *            : Radius
     * @return Umfang eines Kreises
     */
    public double umfangKreis(double r) {
        return 2 * Math.PI * r;
    }

    /**
     * Diese Methode vergleicht zwei Rechtecke nach ihren FlaÃ«cheninhalte
     * 
     * @param r1
     *            : erste Rechtecke
     * @param r2
     *            : zweite Rechtecke
     * @return Falls das erste Rechteck groeÃŸer ist als das zweite, wird 1
     *         zurueckgegeben. Falls das zweite Rechteck groeÃŸer ist als das
     *         erste, wird -1 zurueckgegeben. Wenn aber beide Rechtecke gleich
     *         groÃŸ sind, dann wird 0 zurueckge    liefert.
     */
    public int compare(Rechteck r1, Rechteck r2) {
        if (flaecheninhaltDreieck(r1.getA(), r1.getB()) < flaecheninhaltDreieck(
                r2.getA(), r2.getB()))
            return -1;
        if (flaecheninhaltDreieck(r1.getA(), r1.getB()) > flaecheninhaltDreieck(
                r2.getA(), r2.getB()))
            return 1;
        return 0;
    }
    
    /**
     * In dieser Methode wird die Fakultät n!
     * der Zahl n berechnet. 
     * - n >= 0, ansonsten Fehlermeldung!
     */
    public int fakultaet(int n) {
        int index=1;
        int ergebnis=1;
        if (n>0){
            while(index <= n){
                ergebnis= ergebnis*index;
                index++;
            }
            return ergebnis;
        }
        if (n==0){
            return ergebnis=1;
        }
        System.out.println("Dies ist keine gültige Eingabe! Die Zahl muss positiv sein!");
        return -1;
    }
    
    /**
     * In dieser Methode wird die Fibonacci-Folge
     * bis zum für n gegebenen Wert berechnet.
     * n gibt das letzte Folgenglied an.
     */
    public LinkedList<Integer> fibonacciFolge(int n){
        LinkedList<Integer> fibonacci;
        fibonacci= new LinkedList<Integer>();
        
        fibonacci.add(0,0);
               
        int ergebnis=0;
        int index=2;
        
        if (n==0){
            return fibonacci;
        }
        fibonacci.add(1,1);
        if (n==1){
            return fibonacci;
        }
        if (n>1){
            while(index<=n){
                ergebnis= fibonacci.get(index-1)+fibonacci.get(index-2);
                fibonacci.add(ergebnis);
                index++;
            }
            return fibonacci;
        }
        System.out.println("Dies ist keine gültige Eingabe! Die Zahl muss positiv sein!");
        return null;
    }
    
    public double[] vektoraddition(double[] v1, double[] v2){
        
        int i= v1.length;
        int n= v2.length;        
        
        if (i==n){
            double[] ergebnis;
            double zwischenwert;
            int index=0;
            ergebnis= new double[i];
            while(index<=n-1){
                zwischenwert= v1[index]+v2[index];
                ergebnis[index]=zwischenwert;
                index++;
            }
            return ergebnis; 
        }
        System.out.println("Die Anzahl der Elemente in beiden Vektoren muss gleich sein!");
        return null;
    }
    
    public double[] vektorsubtraktion(double[] v1, double[] v2){
        
        int i= v1.length;
        int n= v2.length;        
        
        if (i==n){
            double[] ergebnis;
            double zwischenwert;
            int index=0;
            ergebnis= new double[i];
            while(index<=n-1){
                zwischenwert= v1[index]-v2[index];
                ergebnis[index]=zwischenwert;
                index++;
            }
            return ergebnis; 
        }
        System.out.println("Die Anzahl der Elemente in beiden Vektoren muss gleich sein!");
        return null;
    }
    
    public double[] skalarmultiplikation(double l, double[] v){
        int i= v.length;       
        double[] ergebnis;
        int index=0;
        ergebnis= new double[i];
        while(index<=i-1){
            ergebnis[index]= l*v[index];
            index++;
        }
        return ergebnis; 
    }
    
    public double laengeDesVektors(double[] v){
        int i= v.length;       
        double ergebnis;
        int index=0;
        double zwischenwert=0;
        while(index<=i-1){
            zwischenwert=zwischenwert+(v[index]*v[index]);
            index++;
        }
        ergebnis= Math.sqrt(zwischenwert);
        return ergebnis;
    }
    
     public double[][] matrizenAddition(double[][] a, double[][] b){
        int index =0;
        double[][]ergebnis;
        if(a.length!=b.length){
            return null;
        }
        while(index<=a.length-1){
            if(a[index].length!=b[index].length){
                return null;
            }
            index++;
        }
        ergebnis= new double [a.length][a[0].length];
        int spaltenindex=0;
        while(spaltenindex<=a.length-1){
            int zeilenindex=0;
            while(zeilenindex<=a[0].length-1){
                ergebnis[spaltenindex][zeilenindex]=a[spaltenindex][zeilenindex]+b[spaltenindex][zeilenindex];
                zeilenindex++;
            }
            spaltenindex++;
        }
        return ergebnis;
    }
    
     public double[][] matrizenSubtraktion(double[][] a, double[][] b){
        int index =0;
        double[][]ergebnis;
        if(a.length!=b.length){
            return null;
        }
        while(index<=a.length-1){
            if(a[index].length!=b[index].length){
                return null;
            }
            index++;
        }
        ergebnis= new double [a.length][a[0].length];
        int spaltenindex=0;
        while(spaltenindex<=a.length-1){
            int zeilenindex=0;
            while(zeilenindex<=a[0].length-1){
                ergebnis[spaltenindex][zeilenindex]=a[spaltenindex][zeilenindex]-b[spaltenindex][zeilenindex];
                zeilenindex++;
            }
            spaltenindex++;
        }
        return ergebnis;
    }
    
     public double[][] matrizenmultiplikation(double[][] a, double[][] b){
       double[][]ergebnis;
       for (int i=0; i<b.length; i++){
           if(a.length[i]!=b.length){
               return null;
           }  
           if(b.length[0]!=b.lenght[i]){
               return null;
           }
       }
        
       ergebnis= new double [a.length][b[0].length];
       double zwischenergebnis=0;
       double multiplikation=0;
       int zeilenindex=0;
       
       for(int j=0; j<a.length; j++){
           for(int k=0; k<b.length[0]; k++){
               for(int n=0; n<b.lenght; n++]{
                   zwischenergebnis=zwischenergebnis+a[j][n]*b[n][k];
               }
               ergebnis[j][k]=zwischergebnis;
           }
       }      
        return ergebnis;
    }
}