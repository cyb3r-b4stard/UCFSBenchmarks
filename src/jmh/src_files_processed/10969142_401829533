import java.util.Comparator;
import java.util.Arrays;

int finalResult = 0;
public class Sorter
{
	/**
	 * Return an instance of a class that realizes the
	 * Comparator interface. The class should be an inner
	 * class. You must write the inner class, then return
	 * an instance of it. It should compare students based
	 * on student id. Students with lower student ids should
	 * come first.
	 * 
	 * @return an instance of a class that implements Comparator<Student>
	 */
	public static Comparator<Student> getStudentIdComparator()
	{
		class StudentIdComparator implements Comparator<Student>
		{
		    public int compare(Student o1, Student o2)
		    {
		        if (o1.getId() < o2.getId()){ return -1;}
		        else if (o1.getId() > o2.getId()){ return 1;}
		        else{ return 0;}
		    }
		}
		StudentIdComparator idC = new StudentIdComparator();
		return idC;
	}
	
	/**
	 * Return an instance of a class that realizes the
	 * Comparator interface. The class should be an inner
	 * class. You must write the inner class, then return
	 * an instance of it. It should compare courses based
	 * on department code. Compare them based on alphabetical
	 * ordering. "cs" comes before "mus"
	 * 
	 * @return an instance of a class that implements Comparator<Course>
	 */
	public static Comparator<Course> getDepartmentComparator()
	{
		class DepartmentComparator implements Comparator<Course>
		{
		    public int compare(Course o1, Course o2)
		    {
		        String o;
		        String o1S = o1.getDepartment();
		        String o2S = o2.getDepartment();
		        if (o1S.length() < o2S.length()){ o = o1S;}
		        else{ o = o2S;}
		        char a = o1S.charAt(0);
		        char b = o2S.charAt(0);
		        for (int i = 0; i < o.length(); i++)
		        {
		            a = o1S.charAt(i);
		            b = o2S.charAt(i);
		            if (a != b){ i = o.length();}
		        }
		        if (a < b){ return -1;}
		        else if (a > b){ return 1;}
		        else{ return 0;}
		    }
		}
		DepartmentComparator dC = new DepartmentComparator();
		return dC;
	}
	
	/**
	 * Use selection sort to sort courses based on the
	 * number of enrolled students. Courses with fewer
	 * students should come first.
	 * 
	 * @param courses the array of courses to sort
	 */
	public static void selectionSortCourses(Course[] courses)
	{
		for (int i = 0; i < courses.length-1; i++)
		{
		    int firstSize = courses[i].size();
		    for (int j = i+1; j < courses.length; j++)
		    {
		        int secondSize = courses[j].size();
		        if (secondSize < firstSize)
		        {
		            Course temp = courses[i];
		            courses[i] = courses[j];
		            courses[j] = temp;
		            j = courses.length;
		        }
		    }
		}
	}
	
	/**
	 * Use merge sort to sort students based on their
	 * last names. Use alphabetical ordering based on
	 * the lastName field. So a student with the last
	 * name "arthur" should come before a student with
	 * the last name "presley".
	 * 
	 * @param students the array to sort
	 */
	public static Student[] mergeSortStudents(Student[] students)
	{
		if (students.length <= 1)
		{
		    return students;
		}
		else
		{
		    int half = students.length/2;
		    Student[] a = Arrays.copyOfRange(students, 0, half);
		    Student[] b = Arrays.copyOfRange(students, half, students.length);
		    Student[] aSort = mergeSortStudents(a);
		    Student[] bSort = mergeSortStudents(b);
		    int ai = 0;
		    int bi = 0;
		    int i = 0;
		    Student[] merged = new Student[students.length];
		    while (i < merged.length)
		    {
		        if (ai >= aSort.length)
		        {
		            merged[i] = bSort[bi];
		            bi++;
		        }
		        else if (bi >= bSort.length)
		        {
		            merged[i] = aSort[ai];
		            ai++;
		        }
		        else if (aSort[ai].getLastName().compareTo(bSort[bi].getLastName()) < 0)
		        {
		            merged[i] = aSort[ai];
		            ai++;
		        }
		        else if (aSort[ai].getLastName().compareTo(bSort[bi].getLastName()) > 0)
		        {
		            merged[i] = bSort[bi];
		            bi++;
		        }
		        i++;
		    }
		    return merged;
		}
	}

	/**
	 * Use binary search on the lastName field to return 
	 * the index where the student is located in the array
	 * or -1 if that student isn't in the array.
	 * 
	 * This will require a recursive helper method.
	 * 
	 * @param students the array to search
	 * @return the index where the student is found, or -1 if not found
	 */
	public static int binarySearchStudents(String lastName, Student[] students)
	{
	    binarySearchStudents(lastName, students, 0);
	    return finalResult;
	}
	
	private static int binarySearchStudents(String lastName, Student[] students, int index)
	{
	    int result = index;
	    System.out.println("Fuck " + result);
	    int half = students.length/2;
	    if (students.length == 0)
	    {
	        result = -1;
	    }
	    else if (students[half].getLastName().compareTo(lastName) == 0)
		{
		    result = result + half;
		}
		else if (students[half].getLastName().compareTo(lastName) < 0)
		{
		    Student[] temp = Arrays.copyOfRange(students, half+1, students.length);
		    result = result + (half + 1);
		    binarySearchStudents(lastName, temp, result);
		}
		else if (students[half].getLastName().compareTo(lastName) > 0)
		{
		    Student[] temp = Arrays.copyOfRange(students, 0, half);
		    binarySearchStudents(lastName, temp, result);
		}
		else if (result >= students.length)
		{
		    result = -1;
		}
		finalResult = result;
	}
}