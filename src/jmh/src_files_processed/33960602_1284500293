
/* #### ### ####### ########## ##
 * ####:
 * ########:
 * ##:
 */

import ecs100.*;
import java.awt.Color;
import java.io.*;
import java.util.*;
import javax.swing.JColorChooser;

/** ### ######## ####### ###### ### #### ## ######, ####, ### ###### #####
 *    ########## ######## ########## ## # #### ## ###### ######.
 *    ### ####### ###### ### #### ##
 *      - ### # ### ##### ## ### #######
 *      - ###### # ##### #### ### #######
 *      - #### # ##### ## # ######### ########
 *      - ### ### ###### ### ### #### #####
 *      - #### ### ####### ####### ## # ####
 *      - #### # ######## ####### #### # ####.
 *    ### ###### ####### #####, ##########, #####, ### ####
 *        
 *    #######
 *      ### ######## ##### ####### ### ### #### ###########:
 *        #######, ##### #######, #### ####### ### #######.
 *        ## ###### ### ####### ####### ## ## ######### ## ##### .
 *
 *      ### ##### ######### ######### ### ##### ####
 *      ### ##### ####### ### ######### ##### ### ######### ######### ##### ## ######.
 *
 *    #####:
 *      # ####### ## ###### ## # #### ########## ### #### ### #### #####,
 *        #### #### #### ##### #### ### #### ## ### #### ## #####,
 *         ######## ## # ############# ## ### #####,
 *         ##### ### ###### (##### ######## ### ###, ####, ### #####)
 *         #### ### ######## (# ### #)
 *         ### ##### ###### #### ###### ## ### #####.
 *        
 *    #### #########:
 *        ##### ### ####### ### ####### #### ### ##### ####### (###, ####, ####),
 *         ####### ### ########## ### #### ##### ## ####, ###
 *         ###### ### ####### ### #####,
 *         ####### ### ######, ######## ### ######## ######.
 */

public class MiniDraw {
    private ArrayList<Shape> shapes = new ArrayList<Shape>();    


    private double pressedX;                 
    private double pressedY;  
    private String currentAction = "Line";   
    private Shape currentShape = null;      
    private Color currentColor = Color.red;

    /** Constructor sets up the GUI:
     *  sets the mouse listener and adds all the buttons
     *  For New, Open, Save, and Color, call the appropriate method (see below)
     *   to perform the action immediately.
     *  For other buttons, store the button name in the currentAction field
     */
    public MiniDraw(){
        /*# YOUR CODE HERE */
        UI.addButton("New", this::newDrawing);
        UI.addButton("Open", this::openDrawing);
        UI.addButton("Save", this::saveDrawing);
        UI.addButton("Line", () -> {this.currentAction = "Line"; });
        UI.addButton("Rect", () -> {this.currentAction = "Rect"; });
        UI.addButton("Oval", () -> {this.currentAction = "Oval"; });
        UI.addButton("Dot", () -> {this.currentAction = "Dot"; });
        UI.addButton("Poly", () -> {this.currentAction = "Poly"; });
        UI.addButton("Color", this::selectColor);
        UI.addButton("Move", () -> {this.currentAction = "Move"; });
        UI.addButton("Delete", () -> {this.currentAction = "Delete"; });
        UI.addButton("Resize", () -> {this.currentAction = "Resize"; });
        UI.setMouseListener(this::doMouse);
    }


    /** When mouse is pressed, remember the position in fields
     *  and also find the shape it is on (if any), and store
     *  the shape in a field (use the findShape(..) method)
     *  When the Mouse is released, depending on the currentAction,
     *  - perform the action (move, delete, or resize).
     *    move and resize are done on the shape where the mouse was pressed,
     *    delete is done on the shape where the mouse was released 
     *  - construct the shape and add to the shapes ArrayList,
     *    (though the polygon is more complicated)
     *  - redraw the drawing.
     *  It is easiest to call other methods (see below) to actually do the work,
     *  otherwise this method gets too big!
     */
    public void doMouse(String mouseAction, double x, double y) {
        if (mouseAction.equals("pressed")){
            this.pressedX = x;
            this.pressedY = y;
            this.currentShape = this.findShape(x, y);
        }
        if (mouseAction.equals("released")){
            if(currentAction.equals("Move")){
                this.moveShape(x-this.pressedX, y-this.pressedY);
            }
            else if(currentAction.equals("Delete")){
                this.deleteShape(pressedX, pressedY);
            }
            else if (currentAction.equals("Resize")){
                this.resizeShape(pressedX, pressed Y);
            }
            else {
                this.addShape(pressedX, pressedY, x, y);
            }
            
            this.drawDrawing();
        }
    }


    /** Draws all the shapes in the list on the graphics pane
     *  First clears the graphics pane, then draws each shape,
     *  Finally repaints the graphics pane
     */
    public void drawDrawing(){
        UI.clearGraphics();
        for( int i = 0; i<shapes.size(); i++){
            shapes.get(i).redraw();
        }
        UI.repaintGraphics();
    }   

    /** Checks each shape in the list to see if the point (x,y) is on the shape.
     *  It returns the topmost shape for which this is true.
     *     Returns null if there is no such shape.
     */
    public Shape findShape(double x, double y){
        for(int i = shapes.size()-1; i>=0; i--){
            Shape s = shapes.get(i);
            if(s.on(x,y)){
                return s;
            }
        }

        return null;  
    }

    /** Sets the current color.
     * Asks user for a new color using a JColorChooser (see MiniPaint, Assig 6)
     * As long as the color is not null, it remembers the color 
     */
    private void selectColor(){
        this.currentColor = JColorChooser.showDialog(null, "Choose Color for new shapes", null);
        UI.setColor(this.currentColor);
    }

    /** Start a new drawing -
     *  initialise the shapes ArrayList and clear the graphics pane. 
     */
    public void newDrawing(){
        this.shapes.clear();
        UI.clearGraphics();
    }

    /** Construct a new Shape object of the appropriate kind
     *    (depending on currentAction) using the appropriate constructor
     *    of the Line, Rectangle, Oval, or Dot classes.
     *    Adds the shape to the end of the collection.
     */
    public void addShape(double x1, double y1, double x2, double y2){
        Trace.printf("Drawing shape %s, at (%.2f, %.2f)-(%.2f, %.2f)\n",
            this.currentAction, x1, y1, x2, y2);  
        double left1 = x1;
        double left2 = x2;
        double top1 = y1;
        double top2 = y2;
        if(x2 < x1){
            left1 = x2;
            left2= x1;
        }
        if (y2 < y1){
            top1 = y2;
            top2 = y1;
        }            
        if (this.currentAction.equals("Line")){
            shapes.add(new Line(x1, y1, x2, y2, this.currentColor));
        }
        else if (this.currentAction.equals("Rect")){
            shapes.add(new Rectangle(left1, top1, left2, top2, this.currentColor));
        }
        else if (this.currentAction.equals("Oval")){
            shapes.add(new Oval(left1, top1, left2, top2, this.currentColor));
        }
        else if (this.currentAction.equals("Dot")){
            shapes.add(new Dot(x1, y1, this.currentColor));
        }

    }

    /** Moves the current shape (if there is one)
     *    to where the mouse was released.
     *    Ie, change its position by (toX-fromX) and (toY-fromY)
     */
    public void moveShape(double changeX, double changeY){
        Trace.printf("Moving shape by (%.2f, %.2f)\n", changeX, changeY);  
        if(this.currentShape != null){
            this.currentShape.moveBy(changeX, changeY);
        }
    }

    /** Finds the shape that was under the mouseReleased position (x, y)
     *    and then removes it from the ArrayList of shapes. 
     *  If not pressed on any shape, then do nothing.
     */
    public void deleteShape(double x, double y){
        Trace.printf("Deleting shape under (%.2f, %.2f)\n", x, y);  
        if (this.currentShape != null){
            this.shapes.remove(currentShape);
        }
    }
    /** Resizes the current shape. A simple way of doing it is to
     *    resize the shape by the amount that the mouse was moved
     *    (ie from (fromX, fromY) to (toX, toY)). 
     *    If the mouse is moved to the right, the shape should
     *    be made that much wider on each side; if the mouse is moved to
     *    the left, the shape should be made that much narrower on each side
     *    If the mouse is moved up, the shape should be made
     *    that much higher top and bottom; if the mouse is moved down, the shape 
     *    should be made that much shorter top and bottom.
     *    The effect is that if the user drags from the top right corner of
     *    the shape, the shape should be resized to whereever the dragged to.
     */
    public void resizeShape(double changeX, double changeY){
        Trace.printf("Changing size of shape by (%.2f, %.2f) \n", changeX, changeY);  
        /*# YOUR CODE HERE */

    }

    /** Adds a polygon [challenge].
     *    If the currentPolygon is null, then create a new polygon with
     *    just the point x,y. Store it in currentPolygon, and add it to shapes.
     *    If the currentPolygon is not null, then add a new point to it.
     *    (Don't add it to shapes, since it is already there).
     *    Note, you need to reset currentPolygon to null every time a button is pressed
     */
    public void addPolygon(double x, double y){
        /*# YOUR CODE HERE */

    }

    /** Ask the user to select a file and save the current drawing to the file. */
    public void saveDrawing(){
        /*# YOUR CODE HERE */
        try {
            File file = new File (UIFileChooser.save("File for MiniDraw"));
            PrintStream ps = new PrintStream(file);
            for( int i =0; i<shapes.size(); i++){
                ps.println(this.shapes.get(i));
            }
        } 
        catch (IOException e){
            UI.println("Fail: " + e);
        }

    }

    /**
     * Ask the user for a file to open,
     * then read all the shape descriptions into the current drawing.
     * For each line of the file, it will read the first token to find out which
     * kind of shape and read the rest of the line into a string.
     * It will then call the appropriate constructor, passing the string as an argument.
     */
    public void openDrawing(){
        /*# YOUR CODE HERE */
        String filename = UIFileChooser.open();
        File myfile = new File(filename);
        UI.clearGraphics();
        try{
            Scanner scan = new Scanner(myfile);
            while(scan.hasNextLine()){
                String shape = scan.next();
                if (shape.equals("Line")){
                    this.shapes.add(new Line (scan.nextLine()));
                }
                else if (shape.equals("Rectangle")){
                    this.shapes.add(new Rectangle (scan.nextLine()));
                }
                else if (shape.equals("Dot")){
                    this.shapes.add(new Dot (scan.nextLine()));
                }
                else if (shape.equals("Oval")){
                    this.shapes.add(new Oval (scan.nextLine()));
                }
                else {
                    scan.nextLine();
                }
            }

        }
        catch(IOException e){
            UI.println("Fail: " + e);
        }
        this.drawDrawing();
    }

    public static void main(String args[]){
        new MiniDraw();
    }

}
