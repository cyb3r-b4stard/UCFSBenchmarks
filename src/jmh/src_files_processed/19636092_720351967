import java.awt.Color;
import java.util.ArrayList;
/**
 * ##### # ########### ## ##### ########## ####.
 * 
 * @###### ######## ######
 * @####### (# ####### ###### ## # ####)
 */
public class SnackBlock
{
    ArrayList<Block> snake = new ArrayList<Block>(); 
    Color color; 

    ArrayList<Location> loc = new ArrayList<Location>();   
    MyBoundedGrid<Block> grid; 
    Block random; 

    /**
     * Constructor for objects of class SnackBlock
     */
    public SnackBlock(MyBoundedGrid<Block> board)

    {
        grid = board; 
        int row = 4;
        int col = 4;
        loc.add(new Location(row, col)); 
        Block head = new Block(loc.get(0)); 
        snake.add(head); 
        addToLocations(grid, loc); 

        int rRandom = 4; 
        int cRandom = 7; 
        random = new Block(new Location(rRandom, cRandom)); 
        random.putSelfInGrid(grid, new Location(rRandom, cRandom)); 

    }

    /**
     * Adds to the snake if it ate a block
     * Adds a prize 
     */
    public boolean gotABlock()
    {

        if (snake.get(0).getLocation().equals(random.getLocation()))
        {
            return true; 
        }
        return false; 

    }

    /**
     * 
     */
    public void addTail()
    {
        if (gotABlock())
        {
            random.removeSelfFromGrid(); 
            Location last = snake.get(snake.size() -1).getLocation(); 
            snake.add(new Block( last.getRow(), last.getCol() -1); 
        }
    }

    /**
     * Removes blocks from the grid
     * 
     * @precondition blocks are in the grid
     * 
     * @return the old locations of the blocks
     */
    private ArrayList<Location> removeBlocks()
    {                                                                                          
        for (int x = 0; x < loc.size(); x++)
        {

            snake.get(x).removeSelfFromGrid(); 

        }
        return loc; 
    }

    /**
     * Turns the snake
     */
    public void turn()
    {
    }

    /**
     * Gets the direction the snake is facing
     */
    public void getDirection()
    {

    }

    /**
     * Moves the snake continiously in its direction
     */
    public boolean translate(int deltaRow, int deltaCol)
    {
        ArrayList<Location> locy = new ArrayList<Location>(); 

        for (int x = 0; x < loc.size(); x++)
        {

            int newRow = loc.get(x).getRow() + deltaRow; 
            int newCol = loc.get(x).getCol() + deltaCol;

            locy.add(new Location(newRow, newCol)); 
        }
        ArrayList<Location> currentLoc = removeBlocks(); 
        if (areEmpty(grid, locy))
        {

            addToLocations(grid, locy); 
            loc = locy; 
            return true; 
        }
        addToLocations(grid, currentLoc); 

        return false; 
    }

    /**
     * Adds block to location
     * @param gr the grid that the blocks are added to
     * @param locs the array of locations that the blocks occupy
     * @precondition:  blocks are not in any grid;
     *                 locs.length = 4.
     * 
     * @postcondition: The locations of blocks match locs,
     *                 and blocks have been put in the grid.
     */
    private void addToLocations(MyBoundedGrid<Block> gr, ArrayList<Location> locs)
    {
        for (int x = 0; x < locs.size(); x++)
        {
            snake.get(x).setColor(Color.CYAN);  
            snake.get(x).putSelfInGrid(gr, locs.get(x)); 

        }
    }

    /**
     * Checks of the locations are empty and valid in the grid
     * 
     * @param gr the grid to be checked
     * @param locs the locations to be checked
     *              
     * @return true if each of locs is valid and empty in grid;
     *                false otherwise. 
     */
    private boolean areEmpty(MyBoundedGrid<Block> gr, ArrayList<Location> locs)
    {
        for (int x = 0; x < locs.size(); x++)
        {
            if (!gr.isValid(locs.get(x)))
            {
                return false; 
            }
            if (gr.get(locs.get(x)) != null)
            {
                return false;
            }

        }
        return true; 
    }
}