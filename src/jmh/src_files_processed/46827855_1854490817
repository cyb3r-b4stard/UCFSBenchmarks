import java.util.*;
import java.lang.*;
/**
 * ############## ########## ### ##### ##### ## ### #### ## ###### (### ######### #### ### #######).
 *
 * ######## # ########### #### ## ########## ##### ####### ### ########### ### ## ### ######### ### ### ##### ## ### ####.
 *
 **/
public class Board implements BoardInterface
{
    private String boardName;
    
    private LocationInterface start;
    private LocationInterface end;
    private LocationInterface knocked;
    private ArrayList<LocationInterface> spaces;
    
    private StringBuilder str;
    private List<DieInterface> dices;
    private DieInterface die1;
    private DieInterface die2;
    private DiceInterface dice;
    
    public Board()
    {
        start = new Location("Start");
        start.setMixed(true);
        try{
            for(int i=0; i < PIECES_PER_PLAYER ; i++)
            {
                start.addPieceGetKnocked(Colour.BLUE);
                start.addPieceGetKnocked(Colour.GREEN);
            }
        }
        catch ( IllegalMoveException m) {}
        end = new Location("End");
        end.setMixed(true);
        knocked = new Location("Knocked");
        knocked.setMixed(true);      
        spaces = new ArrayList<LocationInterface>();
        for(int i = 1; i<= NUMBER_OF_LOCATIONS; i++) 
        { 
            LocationInterface space = new Location("Space" + i);
            space.setMixed(false);
            spaces.add(space);
        }
        dice = new Dice();
        
        

    }

    public void setName(String name)
    {
        this.boardName = name;
    }

    /**
     * @return the Location off the board where all pieces start the game. This will be a mixed location.
     **/
    public LocationInterface getStartLocation()
    {
        return start;
    }

    /**
     * @return the Location off the board where pieces get to when they have gone all the way round the board. This will be a mixed location.
     **/
    public LocationInterface getEndLocation()
    {
        return end;
    }

    /**
     * @return the Location where pieces go to when they are knocked off the board by an opposing piece. This will be a mixed location.
     **/
    public LocationInterface getKnockedLocation()
    {
        return knocked;
    }

    /**
     * @return the Location corresponding to a numbered position on the board. This will not be a mixed location.
     *
     * @param locationNumber the number of the location going from 1-24
     *
     * @throws NoSuchLocationException when position is not in the range 1-24
     **/
    public LocationInterface getBoardLocation(int locationNumber) throws NoSuchLocationException
    {
        LocationInterface boardLocation;
        if(NUMBER_OF_LOCATIONS - locationNumber + 1 > 0)
        {
            boardLocation = spaces.get(locationNumber - 1);
        }
        else 
        {
            throw new NoSuchLocationException("This location does not exist. Must be within the range 1 - " + NUMBER_OF_LOCATIONS);
        }
        return boardLocation;
    }

    /**
     * @param colour the colour to move
     *
     * @param move the move to make
     *
     * @return true if and only if, from the current board state it would be legal for the given colour to make the given move.
     **/
    public boolean canMakeMove(Colour colour, MoveInterface move)
    {
        boolean makeMove = false;
        int locationNumber = move.getSourceLocation();
        int diceValue = move.getDiceValue();
        int newLocation = locationNumber + diceValue ; 
        try {
            if(NUMBER_OF_LOCATIONS - newLocation + 1 > 0)
            {
                 LocationInterface boardLocation = getBoardLocation(newLocation);
                 if(boardLocation.canAddPiece(colour) == true )
                {
                    makeMove = true;
                } 
            }
            else if (newLocation > 24)
            {
                LocationInterface boardLocation = getEndLocation();
                if(boardLocation.canAddPiece(colour) == true )
                {
                   makeMove = true;
                }
            }
            
        }
        catch ( NoSuchLocationException e){
            e.printStackTrace();
        }
        return makeMove;
    }

    /**
     * Update the Board state by making the given move for the given colour, including any knocking off.
     *
     * @param colour the colour to move
     *
     * @param move the move to make
     *
     * @throws IllegalMoveException if and only if the move is not legal.
     **/
    public void makeMove(Colour colour, MoveInterface move) throws IllegalMoveException
    {
        LocationInterface source;
        LocationInterface newSpace;

        if(canMakeMove(colour,move) == true)
        {
            int locationNumber = move.getSourceLocation();
            int diceValue = move.getDiceValue();
            int newLocation = locationNumber + diceValue ; 

            try {

                if(locationNumber == 0)
                {
                    source = getStartLocation();
                }
                else{
                    source = getBoardLocation(locationNumber);
                }

                if(newLocation > 24 )
                {
                    newSpace = getEndLocation();
                    source.removePiece(colour);
                    newSpace.addPieceGetKnocked(colour);
                } else if ( ( newLocation>= 1) && (newLocation <= 24) ) {

                            newSpace = getBoardLocation(newLocation);
                            source.removePiece(colour);
                            if(newSpace.addPieceGetKnocked(colour) != null)
                            {
                                newSpace.removePiece(colour.otherColour());
                                knocked.addPieceGetKnocked(colour.otherColour());
                            }
                        

                }
                    
            } catch ( NoSuchLocationException e){
                e.printStackTrace();
            }
        } else { 
            throw new IllegalMoveException("this move is not legal");
        }

    }

    /**
     * Update the Board state by making the all of the moves in the given turn in order, including any knocking off, based on the given diceValues.
     *
     * @param colour the colour to move
     *
     * @param turn the turn to take
     *
     * @param diceValues the values of the dice available in no particular order. There will be repeated values in the list if a double is thrown
     *
     * @throws IllegalTurnException if and only if the turns in the move are not legal for the diceValues give. Each of the moves has to be legal, and the diceValues in the moves of the turn must match the diceValues parameter. The number of moves in the turn must be no less than the maximum possible number of legal moves: all available dice must be used. If IllegalTurnException is thrown then the board state remains unchanged.
     **/
    public void takeTurn(Colour colour, TurnInterface turn, List<Integer> diceValues) throws IllegalTurnException
    {

        for (Integer v : diceValues)
        {
            MoveInterface move1 = new Move();
            try{
                move1.setDiceValue(v);
            }
            catch(IllegalMoveException e){}
            if(canMakeMove(colour,move1) == true )
            {
                turn.addMove(move1);
            }

        }
        List<MoveInterface> moves = turn.getMoves();
        for (MoveInterface move : moves)
        {
            try{
                makeMove(colour,move);
            }
            catch(IllegalMoveException e)
            {
                throw new IllegalTurnException("this turn cannot happen");
            }
        }
    }

    /**
     * @param colour the colour to check
     *
     * @return true if and only if the given colour has won
     **/
    public boolean isWinner(Colour colour)
    {
        boolean wins = false;
        LocationInterface end = getEndLocation();
        if (end.numberOfPieces(colour) == PIECES_PER_PLAYER )
        {
            wins = true;
        }
        return wins;
    }

    /**
     * @return the colour of the winner if there is one, otherwise null
     **/
    public Colour winner()
    {
        Colour winner = null;
        if(isWinner(Colour.BLUE)== true)
        {
            winner = Colour.BLUE;
        }
        if(isWinner(Colour.GREEN)== true)
        {
            winner = Colour.GREEN;
        }
        return winner;
    }

    /**
     * @return true if and only if the Board is in a valid state (do not need to check whether or not it could be reached by a valid sequence of moves)
     **/
    public boolean isValid()
    {
        boolean valid = false;
        boolean numberValid = false;
        boolean number = false;
        int totalGreen = 0;
        int totalBlue = 0;
        Set<Boolean> numberValid = new HashSet<Boolean>();
        for(LocationInterface space : spaces)
        {
            int green = space.numberOfPieces(Colour.GREEN);
            int blue = space.numberOfPieces(Colour.BLUE);
            boolean validSpace = false;
            if( green == 0 || blue == 0)
            {
                validSpace = true;
            }
            else if (green > 0 && blue == 0)
            {
                validSpace = true;
            }
            else if(blue >0 && green == 0)
            {
                validSpace = true;
            }
            totalGreen = totalGreen + green ;
            totalBlue = totalBlue + blue;
            numberValid.add(validSpace);
        }
        if(numberValid.contains(false))
        {
            numberValid = false;
        }
        else
        {
        numberValid = true;
        }
        int greenStart = start.numberOfPieces(Colour.GREEN);
        int blueStart = start.numberOfPieces(Colour.BLUE);
        int greenEnd = end.numberOfPieces(Colour.GREEN);
        int blueEnd = end.numberOfPieces(Colour.BLUE);
        int greenKnock = knocked.numberOfPieces(Colour.GREEN);
        int blueKnock = knocked.numberOfPieces(Colour.BLUE);
        if((totalGreen + greenStart + greenEnd + greenKnock) == PIECES_PER_PLAYER && (totalBlue + blueStart + blueEnd + blueKnock) == PIECES_PER_PLAYER)
        {
            number = true;
        }
        if(number.equals(true) && numberValid.equals(true)
        {
            valid = true;
        }
        return valid;
    }

    /**
     * @param colour the colour to move next
     *
     * @param diceValues the dice values available to use
     *
     * @return a list of moves that the given colour can make from the current board state with (any one of) the given diceValues
     **/
    public Set<MoveInterface> possibleMoves(Colour colour, List<Integer> diceValues)
    {
        Set<MoveInterface> possibleMoves = new HashSet<MoveInterface>();
        for( LocationInterface space : spaces)
        {
            int numberPieces = space.numberOfPieces(colour);
            if(numberPieces !=0 || start.numberOfPieces(colour) != 0)
            {
                for(Integer d : diceValues)
                {
                    MoveInterface move = new Move();
                    
                     if (canMakeMove(colour,move)== true)
        				{
                               possibleMoves.add(move);
       					 }
       					 
                }
                
            }
             
        }
        return possibleMoves;
    }

    /**
     * @return a copy of the board that can be passed to players to work with
     */
    public BoardInterface clone()
    {
        return null;
    }

    /**
     * Overrides toString() from Object with a suitable String representation of the board state for displaying via the console to a human
     **/
    public String toString()
    {
        String numberedBoard = "";
        String startLoc = start.getName() + start.toString(); 
        String endLoc = end.getName() + end.toString();
        String knockedLoc = knocked.getName() + knocked.toString();
        ArrayList<String> numberedLoc = new ArrayList<String>();
        for(LocationInterface l : spaces)
        { 
            String onBoard = l.getName() +l.toString(); 
            numberedLoc.add(onBoard);
        }
        for(String n : numberedLoc)
        {
             numberedBoard = numberedBoard + n + "\n";
        }
        String board = startLoc + "\n" + numberedBoard + "\n" + endLoc + "\n" + knockedLoc + "\n" ;
        return board;
    }
}
